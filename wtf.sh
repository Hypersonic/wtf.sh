#!/usr/local/bin/bash

VERSION="0.0.0.0.1 \"alphaest of bets\""
declare -A URL_PARAMS # hashtable of url parameters
declare -A HTTP_HEADERS # hashtable of http headers

function log {
    echo "[`date`] $@" 1>&2
}

urldecode() {
    # urldecode <string>

    local url_encoded="${1//+/ }"
    printf '%b' "${url_encoded//%/\\x}"
}

function include_page {
    # include_page <pathname>
    local pathname=$1
    while read -r line; do
        # check if we're in a script line or not ($ at the beginning implies script line)
        # you can't just assign to this in bash, because reasons?
        if [[ "$" = ${line:0:1} ]]
        then
            is_script=true;
        else
            is_script=false;
        fi
        # execute the line.
        if [[ $is_script = true ]]
        then
            cmd="${cmd} ${line#"$"}"
        else
            if [[ -n $cmd ]]
            then
                eval $cmd
                cmd=""
            fi
            echo $line
        fi
    done < ${pathname}
}

function handle_connection {
    # Parse query and any url parameters that may be in the path
    IFS=' ' read method path version
    query=$(echo $path | cut -d\? -f2)
    if [[ $query != $path ]]
    then
        params=($(echo $query | sed "s/\&/ /g"))
        for param in ${params[@]}; do
            key=$(echo $param | cut -d\= -f1)
            value=$(echo $param | cut -d\= -f2)
            URL_PARAMS[$key]=$(urldecode $value)
        done
    fi

    path=$(echo $path | cut -d\? -f1) # strip url parameters
    request=($method $path $version)
    requested_path=$(pwd)/${request[1]}

    # parse headers
    while read line; do
        if [[ $line == `printf "\x0d\x0a"` || $line == `printf "\x0a"` ]]
        then
            break
        else
            a=($line)
            key=${a[0]%?}
            value=${a[@]:1}
            HTTP_HEADERS[$key]=$value
        fi
    done

    # if a directory is requested, append index.html
    if [[ -d ${requested_path} ]]
    then
        if [[ -e "${requested_path}/index.html" ]]
        then
            requested_path="${requested_path}/index.html"
        fi
    fi

    # check for possible directory traversals / other undesirable path elements by
    # removing them and 503-ing if the string was changed
    test_path=$(echo ${requested_path} | sed "s/\.\.//g")
    if [[ ${test_path} != ${requested_path} ]]
    then
        echo "HTTP/1.1 503 Forbidden"
        echo "Content-Type: text/html"
        printf "\r\n\r\n"
        echo "<html><title>503</title><body>503 Forbidden</body></html>"
        log "503: ${request[@]}"
        exit 0; # terminate early for 503
    fi

    if [[ -e ${requested_path} ]]
    then
        echo "HTTP/1.1 200 OK"
        echo "Content-Type: text/html"
        printf "\r\n\r\n"
        if [[ -f ${requested_path} ]]
        then
            include_page ${requested_path};
        else # handle directory listing if it isn't a file
            echo "<h3>Index of ${request[1]}</h3>"
            echo "<ul>"
            for d in `ls ${requested_path}`; do
                size_info=($(du -h ${requested_path} | tail -n 1))
                echo "<li><a href="${request[1]#"/"}/${d}">${d}</a>: ${size_info[0]}</li>"
            done
            echo "</ul>"
            echo "<font size=2>generated by wtf.sh ${VERSION} on $(date)</font>"
        fi
        log "200: ${request[@]}"
        exit 0
    else
        echo "HTTP/1.1 404 Not Found"
        echo "Content-Type: text/html"
        printf "\r\n\r\n"
        echo "<html><title>404</title><body>404, not found:<code>${request[1]}</code></body></html>"
        log "404: ${request[@]}"
        exit 0
    fi
}

# start socat on specified port
function start_server {
    socat TCP-LISTEN:$2,fork,readbytes=4096 EXEC:"$1 -r" 2>&1 | tee webserver.log
}

if [[ $# != 1 ]]
then
    echo "Usage: $0 port"
    exit
fi

if [[ $1 == '-r' ]]
then
    handle_connection
else
    start_server $0 $1 # start server on specified port
fi
